# 2. 베스트앨범 / 해시
# https://programmers.co.kr/learn/courses/30/lessons/42579
# ---------문제 설명----------------------------------------------------------------------
# 스트리밍 사이트에서 장르 별로 가장 많이 재생된 노래를 [두 개씩] 모아 베스트 앨범을 출시하려 합니다. 노래는 고유 번호로 구분하며, 노래를 수록하는 기준은 다음과 같습니다.
# 속한 노래가 많이 재생된 장르를 먼저 수록합니다.
# 장르 내에서 많이 재생된 노래를 먼저 수록합니다.
# 장르 내에서 재생 횟수가 같은 노래 중에서는 고유 번호가 낮은 노래를 먼저 수록합니다.
# 노래의 [장르]를 나타내는 문자열 배열 genres와 [노래별 재생 횟수]를 나타내는 정수 배열 plays가 주어질 때, 베스트 앨범에 들어갈 노래의 고유 번호를 순서대로 return 하도록 solution 함수를 완성하세요.

# 제한사항
# genres[i]는 [고유번호]가 i인 노래의 장르입니다.
# plays[i]는 고유번호가 i인 노래가 재생된 횟수입니다.
# genres와 plays의 길이는 같으며, 이는 1 이상 10,000 이하입니다.
# 장르 종류는 100개 미만입니다.
# 장르에 속한 곡이 하나라면, 하나의 곡만 선택합니다.
# 모든 장르는 재생된 횟수가 다릅니다.

# 입출력 예
# genres	                                        plays                   	return
# ["classic", "pop", "classic", "classic", "pop"]	[500, 600, 150, 800, 2500]	[4, 1, 3, 0]

# ---------문제 해석---------------------------------------------------------------------- 
# 장르마다 최대 두 개까지의 노래를 수록한다.(재생횟수가 많은 두 곡)
# 정렬 순서
# 1.속한 노래들의 재생횟수를 모두 더하여, 장르 순서로 먼저 정렬한다.   
#       ※ 재생횟수 합이 같으면? => 제한사항 없음? => 1번 정렬 패스? ======> 제한사항 마지막 - 모든 장르는 재생된 횟수가 다르다 
#       ※ 재생횟수의 합은 2곡의 합인지? or 해당 장르 전체의 합인지?  => 먼저 전체 합으로 진행 
# 2.장르로 먼저 정렬한 뒤, 그 안에서 노래 각각의 재생횟수로 정렬한다.
# 3.재생횟수가 같으면 고유번호=인덱스 순서로 정렬한다. 

# ---------접근 방법---------------------------------------------------------------------- 
# 노래의 인덱스(고유번호)를 key로, 장르이름을 value로 해시를 생성해서 장르(value)별 재생횟수를 가져오도록 구성해본다.
# ----------------------------------------------------------------------------------------

genres = ["classic", "pop", "classic", "classic", "pop"]
plays = [500, 600, 150, 800, 2500]

def solution(genres, plays):
    answer = []
    hash = {}   
    sumGenres = {}   
 
    for i in range(len(genres)):
        hash.setdefault(i, [genres[i], plays[i]])   # {고유번호 : [장르,재생횟수]} 해시 생성  -> 각각의 노래마다 [장르, 재생횟수]를 연결
        
        sumGenres.setdefault(genres[i], 0)   # {장르 : 장르별 재생횟수의 합} 해시 생성  -> 재생횟수 많은 장르별로 가장 먼저 정렬하기 위한 dictionary
        sumGenres[genres[i]] += plays[i]    # 장르(key)가 같으면 재생횟수(value)를 중복해서 더해준다 

    print("hash : ", hash)
    print("sum : ", sumGenres)
    # 재생횟수를 기준으로 내림차순 정렬 
    hash = sorted(hash.items(), reverse=True, key = lambda item : item[1][1])   
    sumGenres = sorted(sumGenres.items(), reverse=True, key = lambda item : item[1])

    print("hash : ", hash)
    print("sum : ", sumGenres)

    index = 0
    while index < len(sumGenres):   # 정렬된 장르를 기준으로, 모든 장르 검색이 끝날때까지 반복 
        count = 0 
        for h in hash:
            if count < 2:   # 한 장르의 노래가 2개이면 반복문을 빠져나와 다음 index(다음 장르)의 곡을 찾는다
                if h[1][0] == sumGenres[index][0]:  # 노래의 집합인 hash를 돌면서 장르가 같으면 
                    answer.append(h[0])     
                    count += 1  # 한 장르의 노래를 추가할 떄마다 누적
        index += 1

    print(answer)
    return answer

solution(genres, plays)

# return = [4, 1, 3, 0]

# ----------------------------------------------------------------------------------------

# 프로그래머스 코드정확도 채점 - 합계:  / 100.0




