# 15.비밀지도 / 진법변환과 비트연산
# https://programmers.co.kr/learn/courses/30/lessons/17681
# 2018 KAKAO BLIND RECRUITMENT - 1차

# ----------------------------------------------------------------------------------------

# 문제 설명
# 네오는 평소 프로도가 비상금을 숨겨놓는 장소를 알려줄 비밀지도를 손에 넣었다. 
# 그런데 이 비밀지도는 숫자로 암호화되어 있어 위치를 확인하기 위해서는 암호를 해독해야 한다. 다행히 지도 암호를 해독할 방법을 적어놓은 메모도 함께 발견했다.

# 1. 지도는 한 변의 길이가 n인 정사각형 배열 형태로, 각 칸은 "공백"(" ") 또는 "벽"("#") 두 종류로 이루어져 있다.
# 2. 전체 지도는 두 장의 지도를 겹쳐서 얻을 수 있다. 각각 "지도 1"과 "지도 2"라고 하자. 지도 1 또는 지도 2 중 어느 하나라도 벽인 부분은 전체 지도에서도 벽이다. 
# 지도 1과 지도 2에서 모두 공백인 부분은 전체 지도에서도 공백이다.
# 3. "지도 1"과 "지도 2"는 각각 정수 배열로 암호화되어 있다.
# 4. 암호화된 배열은 지도의 각 가로줄에서 벽 부분을 1, 공백 부분을 0으로 부호화했을 때 얻어지는 이진수에 해당하는 값의 배열이다.


# 지도사진


# 입력 형식
# 입력으로 지도의 한 변 크기 n 과 2개의 정수 배열 arr1, arr2가 들어온다.


# 출력 형식
# 원래의 비밀지도를 해독하여 '#', 공백으로 구성된 문자열 배열로 출력하라.


# 입출력 예제

# 매개변수	값
# n	        5
# arr1	    [9, 20, 28, 18, 11]
# arr2  	[30, 1, 21, 17, 28]

# 출력  	
# ["#####","# # #", "### #", "# ##", "#####"]

# 매개변수	값
# n	        6
# arr1	    [46, 33, 33 ,22, 31, 50]    
# arr2  	[27 ,56, 19, 14, 14, 10]

# 출력  	
# ["######", "### #", "## ##", " #### ", " #####", "### # "]

# ----------------------------------------------------------------------------------------

# 문제 해석
# 각 배열에 주어지는 정수값을 2진수로 변환하여(지도조각 생성), 인덱스 순으로 위에서 아래로 정렬하면 각각의 지도가 만들어진다
# 각 지도를 겹치면 전체지도를 얻을 수 있는데, 지도 중 하나라도 벽(1)인 부분은 전체지도에서 벽(1)이 된다 -> OR비트연산 사용
# 만들어진 전체지도를 2진수로 표현한 후, 1을 #으로, 0을 공백으로 바꾸면 결과값을 얻을 수 있다

# 접근 방법
# 각각의 지도를 의미하는 정수배열을 2진법으로 변환한다
# 동일한 인덱스끼리 OR연산하여 벽(1)을 찾아낸다 
# OR연산이 모두 끝나면 비밀지도가 완성된 것이므로, 벽(1)은 #으로, 길(0)은 공백으로 변환한다 
# 변환이 끝난 이진수 배열을 리턴

# ----------------------------------------------------------------------------------------

# n1 = 5
# arr1_1 = [9, 20, 28, 18, 11]
# arr1_2 = [30, 1, 21, 17, 28]

# n1 = 6
# arr2_1 = [46, 33, 33 ,22, 31, 50]    
# arr2_2 = [27 ,56, 19, 14, 14, 10]


# def solution(n, arr1, arr2):
#     answer = [] 

#     for i in range(len(arr1)):  # 정수배열을 순환
#         binary = (bin(arr1[i] | arr2[i]))       # 두 정수배열을 OR연산 한 후에 2진화
#         binary = binary[2: ].replace("1","#").replace("0"," ")   
#         # 2진수로 표현된 String에서 0b부분을 제거하고, 벽을 #으로, 길을 공백으로 변환
        
#         # binary = (bin(arr1[i] | arr2[i]))[2: ].replace("1","#").replace("0"," ")  # 위의 두 줄을 하나로 합쳤을 때        

#         answer.append(binary)   

#     return answer

# print(solution(n1,arr1_1,arr1_2))
# print(solution(n1,arr2_1,arr2_2))

# 풀이출력 
# return1 ["#####","# # #", "### #", "# ##", "#####"]
# return2 ['######', '###  #', '##  ##', '#### ', '#####', '### # ']

# ---------1차 오답---------------------------------------------------------------------- 
# 정답출력
# return1 ["#####","# # #", "### #", "# ##", "#####"]
# return2 ["######", "### #", "## ##", " #### ", " #####", "### # "]

# 문제
# - 풀이에는 0마다 공백을 추가하여 공백이 2칸 이상일 때가 있는 것에 반하여, 
#  정답출력에는 공백이 연속된 경우에 공백 1칸으로 처리되어 있음  

# =========> 문제아님 - 다른 부분이 문제였음 

# 실제로 문제였던 부분
# - 정수값을 2진수로 변환한 지도조각의 길이가 전체지도의 변의 길이(n)보다 작으면 에러
# - 부족한 자릿수는 2진수의 길이가 짧아서 발생하는데, 부족한만큼 왼쪽에 [0 = 공백]을 채워주어야 한다
# ----------------------------------------------------------------------------------------

n1 = 5
arr1_1 = [9, 20, 28, 18, 11]
arr1_2 = [30, 1, 21, 17, 28]

n2 = 6
arr2_1 = [46, 33, 33 ,22, 31, 50]    
arr2_2 = [27 ,56, 19, 14, 14, 10]


def solution(n, arr1, arr2):
    answer = [] 

    for i in range(len(arr1)):  # 정수배열을 순환
        binary = (bin(arr1[i] | arr2[i]))[2: ] # 두 정수배열을 OR연산 한 후에 2진수화, String인 2진수에서 앞쪽의 0b를 제거
        
        if len(binary) < n:     # 변환한 2진수(지도조각)가 전체지도 변의 길이보다 작으면
            gap = n - len(binary)   
            binary = ("0" * gap) + binary   # 그 차이만큼 왼쪽에 0을 추가

        binary = binary.replace("1","#").replace("0"," ")   # 1은 #으로 / 0은 공백으로 변환

        answer.append(binary)   # 변환완료한 2진수를 추가

    return answer

print(solution(n1,arr1_1,arr1_2))
print(solution(n2,arr2_1,arr2_2))


# return1 ["#####","# # #", "### #", "# ##", "#####"]
# return2 ["######", "### #", "## ##", " #### ", " #####", "### # "]

# 프로그래머스 코드정확도 채점 - 합계: 100.0 / 100.0

# bin()메소드로 2진법변환 한 뒤에는 String타입이 됨
# String타입은 OR연산을 진행할 수 없으므로, 2진법 변환은 가장 마지막에 실행 
# 두 배열의 정수들을 바로 OR연산 -> 2진수화 -> 지도조각으로 정제 -> 전체지도 리스트에 추가 




