# 5.모의고사 / 완전탐색과 이분탐색 
# https://programmers.co.kr/learn/courses/30/lessons/42840

# ----------------------------------------------------------------------------------------

# 문제 설명
# 수포자는 수학을 포기한 사람의 준말입니다. 수포자 삼인방은 모의고사에 수학 문제를 전부 찍으려 합니다. 
# 수포자는 1번 문제부터 마지막 문제까지 다음과 같이 찍습니다.

# 1번 수포자가 찍는 방식: 1, 2, 3, 4, 5, // 1, 2, 3, 4, 5, ...
# 2번 수포자가 찍는 방식: 2, 1, 2, 3, 2, 4, 2, 5, // 2, 1, 2, 3, 2, 4, 2, 5, ...
# 3번 수포자가 찍는 방식: 3, 3, 1, 1, 2, 2, 4, 4, 5, 5, // 3, 3, 1, 1, 2, 2, 4, 4, 5, 5, ...

# 1번 문제부터 마지막 문제까지의 정답이 순서대로 들은 배열 answers가 주어졌을 때, 
# 가장 많은 문제를 맞힌 사람이 누구인지 배열에 담아 return 하도록 solution 함수를 작성해주세요.

# 제한 조건
# 시험은 최대 10,000 문제로 구성되어있습니다.
# 문제의 정답은 1, 2, 3, 4, 5중 하나입니다.
# 가장 높은 점수를 받은 사람이 여럿일 경우, return하는 값을 오름차순 정렬해주세요.

# 입출력 예 #1
# answers	    return
# [1,2,3,4,5]	[1]
# 수포자 1은 모든 문제를 맞혔습니다.
# 수포자 2는 모든 문제를 틀렸습니다.
# 수포자 3은 모든 문제를 틀렸습니다.
# 따라서 가장 문제를 많이 맞힌 사람은 수포자 1입니다.

# 입출력 예 #2
# answers	    return
# [1,3,2,4,2]	[1,2,3]
# 모든 사람이 2문제씩을 맞췄습니다.

# ----------------------------------------------------------------------------------------

# 문제 해석
# 1,2,3번 수포자 모두 일정한 패턴으로 답을 찍는다
# [수포자가 찍은 답]과 [정답]의 문제번호는 같다
# 문제의 개수는 수포자의 패턴 길이와 일치하지 않을 수 있다 

# 접근 방법
# [수포자가 찍은 답]과 [정답] 각각 전체를 비교해야 하므로 완전탐색으로 반복문을 사용해본다
# [수포자가 찍은 답]과 [정답]의 공통적인 index를 기준으로 삼는다
# 함수 solution의 파라미터는 answer 하나이므로, 수포자 1,2,3의 패턴을 함수 안에서 정의한다 
# 패턴을 어떤 방법으로 정형화해서 answer와 비교할지 고민해보고, 되도록이면 패턴을 객체로 정의하도록 시도해본다 
# 패턴과 문제의 길이가 일치해야 한다는 것과 마지막 정렬에 유의한다 

# ----------------------------------------------------------------------------------------

answer1 = [1,2,3,4,5]	
answer2 = [1,3,2,4,2]

def solution(answers):
    student1 = [1, 2, 3, 4, 5] 
    student2 = [2, 1, 2, 3, 2, 4, 2, 5] 
    student3 = [3, 3, 1, 1, 2, 2, 4, 4, 5, 5] 
    score = []   # 학생들의 점수 리스트 
    rank = []    # 점수의 순위 

    def stuAnswer(students):  # 학생의 패턴을 파라미터로, 점수를 구하는 함수  (answer의 길이와 일치)
        if len(students) < len(answers):      # 패턴길이보다 정답길이가 길면 => [패턴길이] + [패턴 중간에 잘린 지점]
            students = students * ( ( len(answers) // len(students) ) ) + students[ : (len(answers) % len(students)) ] 
        else:
            students = students[ : len(answers)]   # 패턴길이가 정답길이보다 길거나 같으면 => [패턴 중간에 잘린 지점] or [패턴길이] (=[정답길이])
# ------------------------패턴으로 답안지 만들기 완료----------------------------------
        for i in range(len(answers)):   # 정답 리스트 전체를 순환하면서
            if answers[i] == students[i]:   # 답안이 정답과 같으면
                students[i] = True          # 해당 문제 답안을 1점으로 교체
            else : 
                students[i] = False         # 정답과 다르면 0점 
    
        students = sum(students[:])         # 답안지를 총점으로 교체 
        score.append(students)              # 총점 리스트를 생성
        return students                 
    
    student1 = stuAnswer(student1)  # 학생마다 총점 산출 
    student2 = stuAnswer(student2)
    student3 = stuAnswer(student3)

    for i in range(len(score)):     # 총점 리스트 전체를 순환하면서 
        if score[i] == max(student1, student2, student3):   # 어떤 학생의 총점이 최고점과 같으면 
            rank.append(i+1)     # 반환할 값에 추가 

    return rank

print(solution(answer1))
print(solution(answer2))

# 프로그래머스 코드정확도 채점 - 합계: 100.0 / 100.0
# 코드를 더 간단하게 짜보기 