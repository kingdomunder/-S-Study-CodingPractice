# 9.DFS와 BFS / DFS와 BFS
# https://www.acmicpc.net/problem/1260

# ----------------------------------------------------------------------------------------

# 문제
# 그래프를 DFS로 탐색한 결과와 BFS로 탐색한 결과를 출력하는 프로그램을 작성하시오. 
# 단, 방문할 수 있는 정점이 여러 개인 경우에는 정점 번호가 작은 것을 먼저 방문하고, 더 이상 방문할 수 있는 점이 없는 경우 종료한다. 
# 정점 번호는 1번부터 N번까지이다.

# 입력
# 첫째 줄에 정점의 개수 N(1 ≤ N ≤ 1,000), 간선의 개수 M(1 ≤ M ≤ 10,000), 탐색을 시작할 정점의 번호 V가 주어진다. 
# 다음 M개의 줄에는 간선이 연결하는 두 정점의 번호가 주어진다. 
# 어떤 두 정점 사이에 여러 개의 간선이 있을 수 있다. 
# 입력으로 주어지는 간선은 양방향이다.

# 출력
# 첫째 줄에 DFS를 수행한 결과를, 그 다음 줄에는 BFS를 수행한 결과를 출력한다. 
# V부터 방문된 점을 순서대로 출력하면 된다.

# 예제 입력 1 
# 4 5 1
# 1 2
# 1 3
# 1 4
# 2 4
# 3 4

# 예제 출력 1 
# 1 2 4 3
# 1 2 3 4

# 예제 입력 2 
# 5 5 3
# 5 4
# 5 2
# 1 2
# 3 4
# 3 1

# 예제 출력 2 
# 3 1 2 5 4
# 3 1 4 2 5

# 예제 입력 3 
# 1000 1 1000
# 999 1000

# 예제 출력 3 
# 1000 999
# 1000 999

# ----------------------------------------------------------------------------------------

# 문제 해석
# 입력
# 첫째 줄에는 N , M , V 가 주어진다  -  예제1) 4 5 1
# [N = 4]는 정점의 개수, [M = 5]는 간선의 개수(정점 간에 이어지는 선), [V = 1]은 탐색을 시작하는 정점의 번호이다 
# 둘째 줄부터 입력의 끝까지 주어지는 숫자들은 간선을 의미한다 

# 출력
# 예제1) 에서 탐색은 [정점 1]부터 시작한다(V가 1이므로)
# [정점 1]에 간선으로 연결된 [정점 2,3,4]가 [정점 1]의 결과로 나타난 경우의 수에 해당한다 
# 여기부터 DFS와 BFS의 방향이 달라지게 된다 
# 방문할 수 있는 정점이 여러 개인 경우에는 정점 번호가 작은 것을 먼저 방문하므로,

# DFS를 적용하면 [정점 1] - [정점 2]를 방문한 이후에 [정점 2]를 기준으로 한 간선으로 넘어가게 된다
# [정점 2]를 기준으로 한 간선으로 넘어가면, [정점 2] - [정점 4]를 방문하고, 다시 [정점 4]를 기준으로 한 간선으로 넘어간다
# [정점 4]를 기준으로 한 간선이 없으므로, 윗 단계로 거슬러 올라가 기준은 다시 [정점 2]가 된다 
# [정점 2]를 기준으로 한 다른 간선이 없으므로, 윗 단계로 거슬러 올라가 기준은 다시 [정점 1]이 된다 
# [정점 1]을 기준으로 한 간선으로 넘어가고, [정점 2]는 방문했으므로 [정점 1] - [정점 3]을 방문하고, 다시 [정점 3]을 기준으로 한 간선으로 넘어간다 
# [정점 3]을 기준으로 한 간선으로 넘어가면 [정점 4]가 연결되어 있으나 이미 방문한 정점이고, 모든 정점을 방문했으므로 DFS 로직이 종료된다 

# BFS를 적용하면  [정점 1] - [정점 2]를 방문한 이후에 [정점 1]의 다른 모든 간선을 방문한다
# [정점 1]의 모든 간선을 방문하면 모든 정점을 방문하게 되므로, BFS로직이 종료된다

# 접근 방법

# BFS를 적용했을 때 예제1)의 경우에는 한 번의 단계에 모든 정점을 방문했지만, 정점 1과 연결되어있지 않은 정점이 있었다면 방문하도록 해야 한다
# 이 경우에는 [정점 1]의 간선 중 가장 번호가 작은 [정점 2]의 간선을 기준으로 탐색하도록 로직을 구현해본다 

# DFS에는 스택을, BFS에는 큐를 활용하도록 식을 구현해본다 

# ----------------------------------------------------------------------------------------

# 예제 입력 1 
# 4 5 1
# 1 2
# 1 3
# 1 4
# 2 4
# 3 4

# 예제 입력 2 
# 5 5 3
# 5 4
# 5 2
# 1 2
# 3 4
# 3 1

# 예제 입력 3 
# 1000 1 1000
# 999 1000

n,m,v = 4,5,1
fromTo = [[1,2],[1,3],[1,4],[2,4],[3,4]]   

def solution(N,M,V):

    # DFS
    stack = []       # 조사할 정점들을 담을 스택 (가장 작은 번호의 정점부터 꺼낸다 -DFS)
    stack.append(V)  # 방문을 시작할 정점 = V  -> 스택에 담는다 
    visited = []     # 방문한 순서대로 담을 리스트 

    while len(stack)>0:
        now = stack.pop() # [방문한 정점]을 스택에서 꺼냄 

        for i in fromTo:
            if (now == i[0]) :  # [방문한 정점]이 간선의 시작정점과 같으면

            elif now == False:  # [방문한 정점]이 이전 회차에 방문했던 정점이면
                break

        for i in range(len(stack)):    # 스택에 [방문한 정점]이 중복되어 있다면 False로 교체 (하나의 정점에 여러 간선이 있을 때, 한 번만 방문하도록 설정)
            if now == stack[i]:
                stack[i] = False
        
        print(stack)

        visited.append(now) # 방문한 정점에 추가 (방문한 순서대로)

    return visited




print(solution(4,5,1))






# 예제 출력 1 
# 1 2 4 3
# 1 2 3 4

# 예제 출력 2 
# 3 1 2 5 4
# 3 1 4 2 5

# 예제 출력 3 
# 1000 999
# 1000 999

# 프로그래머스 코드정확도 채점 - 합계:  / 100.0