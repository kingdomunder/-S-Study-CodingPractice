# 35. 구명보트 / 탐욕법
# https://programmers.co.kr/learn/courses/30/lessons/42885
# ----------------------------------------------------------------------------------------
# 문제 설명
# 무인도에 갇힌 사람들을 구명보트를 이용하여 구출하려고 합니다. 구명보트는 작아서 한 번에 최대 2명씩 밖에 탈 수 없고, 무게 제한도 있습니다.

# 예를 들어, 사람들의 몸무게가 [70kg, 50kg, 80kg, 50kg]이고 구명보트의 무게 제한이 100kg이라면 2번째 사람과 4번째 사람은 같이 탈 수 있지만 
# 1번째 사람과 3번째 사람의 무게의 합은 150kg이므로 구명보트의 무게 제한을 초과하여 같이 탈 수 없습니다.

# 구명보트를 최대한 적게 사용하여 모든 사람을 구출하려고 합니다.

# 사람들의 몸무게를 담은 배열 people과 구명보트의 무게 제한 limit가 매개변수로 주어질 때, 
# 모든 사람을 구출하기 위해 필요한 구명보트 개수의 최솟값을 return 하도록 solution 함수를 작성해주세요.
# ----------------------------------------------------------------------------------------
# 제한사항
# 무인도에 갇힌 사람은 1명 이상 50,000명 이하입니다.
# 각 사람의 몸무게는 40kg 이상 240kg 이하입니다.
# 구명보트의 무게 제한은 40kg 이상 240kg 이하입니다.
# 구명보트의 무게 제한은 항상 사람들의 몸무게 중 최댓값보다 크게 주어지므로 사람들을 구출할 수 없는 경우는 없습니다.

# 입출력 예
# people	        limit	return
# [70, 50, 80, 50]	100	     3
# [70, 80, 50]  	100	     3

# ---------문제 해석---------------------------------------------------------------------- 
# 무게제한에 걸리지 않으면 구명보트에 여러 명이 탈 수 있다.
# 구명보트의 개수는 제한이 없지만, 최소로 사용해야 한다.

# ---------접근 방법---------------------------------------------------------------------- 
# 정렬불가 제한이 없으므로, 배열 people을 오름차순으로 정렬한다.
# people을 for문으로 돌면서 원소값들을 누적시키다가, 누적값이 무게제한을 초과하면 조건에 걸리도록 한다. 
# 조건에 걸리면 누적값을 초기화하고 걸린 원소에 새로운 구명보트를 할당한다(+1).
# 결국 각 구명보트마다 최대인원을 탑승시키는 것 = 탐욕법이 된다. 

# ----------------------------------------------------------------------------------------

people1, people2 = [70, 50, 80, 50], [70, 80, 50]
limit1, limit2 = 100, 100

def solution(people, limit):
    answer = len(people)    #모든 사람에게 구명보트 1개씩 할당(default)
    people.sort(reverse=True)   #무게를 내림차순 정렬
    index = -1      #가장 가벼운 사람을 비교대상으로 삼기 위한 인덱스값

    for i in range(len(people)):
        if i >= (len(people)+index):    #반복문 탈출조건 - 무거운 사람과 가벼운 사람이 만나는 지점
            break
        elif (people[i] + people[index]) <= limit:  #[가장 무거운 사람 + 가장 가벼운 사람]이 무게제한에 걸리지 않으면
            answer -= 1     #구명보트의 default값에서 하나를 차감(보트 하나에 두 명이 탑승)
            index += -1     #가장 가벼운 사람이 탑승했으므로, 다음으로 가벼운 무게를 비교대상으로 삼음(무거운 사람은 for문으로 자동 순환)

    return answer

print(solution(people1, limit1))
print(solution(people2, limit1))

# return1 = 3
# return2 = 3

# ----------------------------------------------------------------------------------------

# 프로그래머스 코드정확도 채점 - 합계:  100.0 / 100.0

# 두 번의 while문 -> 한 번의 range for문으로 변경
# .pop() -> 조건부로 누적되는 index를 활용

# --------------------------------------------------------------------------------------


# ---------1차 오답---------------------------------------------------------------------- 
# => 1. 보트는 최대 2명까지만 탑승할 수 있다는 점을 간과함.
# => 2. 가장 가벼운 무게끼리 탑승시키면 최솟값을 구할 수 없음 - 가장 가벼운 무게와 가장 무거운 무게를 같이 탑승시키는 것이 최선 
# ----------------------------------------------------------------------------------------

# people1, people2 = [70, 50, 80, 50], [70, 80, 50]
# limit1, limit2 = 100, 100

# def solution(people, limit):
#     answer = 0
#     weight = 0

#     people.sort() 
#     answer += 1     #첫 구명보트 추가 
#     for now in people:    
#         if not (weight + now) > limit:  #무게를 더했는데 무게제한을 초과하지 않으면
#             weight += now                   #기존 구명보트에 무게를 계속 누적 
#         else:               #무게를 더했는데 무게제한을 초과하면
#             answer += 1        #새로운 구명보트를 추가
#             weight = 0         #무게를 초기화
#             weight += now        #새로운 구명보트에 새로운 무게 누적 

#     return answer

# solution(people1, limit1)
# solution(people2, limit2)

# 프로그래머스 코드정확도 채점 - 합계: 30.0 / 100.0 - 정확성 : 20.0, 효율성 : 10.0

# --------------------------------------------------------------------------------------


# ---------2차 오답---------------------------------------------------------------------- 
# => 1. 효율성 문제 -> .pop() 메소드나 while문을 뺄 수 있도록 알고리즘을 수정해본다.
# ----------------------------------------------------------------------------------------

# people1, people2 = [70, 50, 80, 50], [70, 80, 50]
# limit1, limit2 = 100, 100

# def solution(people, limit):  
#     answer = len(people)      #모든 사람에게 구명보트 1개씩 할당(default)
#     people.sort()     #무게를 오름차순 정렬

#     while len(people) > 1:    #반복문 탈출조건 - 사람이 1명 남을 때까지
#         Min = people.pop(0)   #가장 가벼운 사람을 Min으로 설정

#         while len(people) > 0:    #2차반복문 탈출조건 - 혼자 타야하는 무거운 사람들 수가 0이 될때까지
#             if (Min + people.pop(-1)) > limit:    #무게제한 초과하면 보트 차감하지 않고 계속 반복
#                 continue
#             else:
#                 answer -= 1   #무게제한 초과하지 않으면 보트 차감하고, 반복문 탈출(Min새로 설정하기 위해)
#                 break

#     return answer

# print(solution(people1, limit1))
# print(solution(people2, limit1))

# ----------------------------------------------------------------------------------------

# 정확성  테스트
# 테스트 1 〉	통과 (1.89ms, 10.3MB)
# 테스트 2 〉	통과 (0.80ms, 10.3MB)
# 테스트 3 〉	통과 (1.14ms, 10.2MB)
# 테스트 4 〉	통과 (1.17ms, 10.2MB)
# 테스트 5 〉	통과 (0.47ms, 10.2MB)
# 테스트 6 〉	통과 (0.39ms, 10.1MB)
# 테스트 7 〉	통과 (0.38ms, 10.2MB)
# 테스트 8 〉	통과 (0.06ms, 10.2MB)
# 테스트 9 〉	통과 (0.09ms, 10.2MB)
# 테스트 10 〉	통과 (0.75ms, 10.2MB)
# 테스트 11 〉	통과 (0.81ms, 10.2MB)
# 테스트 12 〉	통과 (0.60ms, 10.3MB)
# 테스트 13 〉	통과 (1.21ms, 10.2MB)
# 테스트 14 〉	통과 (0.77ms, 10.2MB)
# 테스트 15 〉	통과 (0.07ms, 10.2MB)

# 효율성  테스트
# 테스트 1 〉	실패 (시간 초과)--------------------------
# 테스트 2 〉	통과 (8.83ms, 10.5MB)
# 테스트 3 〉	통과 (26.79ms, 10.5MB)
# 테스트 4 〉	통과 (8.31ms, 10.6MB)
# 테스트 5 〉	통과 (8.71ms, 10.6MB)

# 프로그래머스 코드정확도 채점 - 합계:  95.0 / 100.0

# ----------------------------------------------------------------------------------------