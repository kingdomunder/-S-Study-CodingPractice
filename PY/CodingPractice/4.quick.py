# list = [6,8,3,9,10,1,2,4,7,5]

# 우선 리스트에서 기준값을 하나 정해야 합니다.
# 편의상 리스트의 맨 마지막 값을 기준값으로 정하였습니다.

# list = [6,8,3,9,10,1,2,4,7,5]의 기준 값 : 5

# 기준값보다 작은 값을 저장할 리스트로 g1 , 큰 값을 저장할 리스트로 g2를 만듭니다.
# g1 : [ ]
# g2 : [ ]

# 리스트에 있는 자료들을 기준 값인 5와 차례로 비교하여 5보다 작은 값은 g1, 5보다 큰 값은
# g2에 넣습니다. 예를 들어 6은 5보다 크므로 g2에 넣고, 그 다음 값인 8도 5보다 크므로 g1에 넣고
# 3은 5보다 작으므로 g1에 넣습니다.
# g1 : [3,1,2,4]
# g2 : [6,8,9,10,7]

# 재귀호출을 이용하여 g1을 정렬합니다. 함수 안에서 퀵 정렬을 재귀 호출하면서 문제를 풀어 정렬합니다.
# g1 : [1,2,3,4]

# 재귀호출를 이용하여 g2를 정렬합니다. 마찬가지로 퀵 정렬로 문제를 풀어 정렬합니다.
# g2 : [6,7,8,9,10]

# 이제 g1에는 '기준보다 작은 값들'이 정렬되어 있고, g2에는 '기준보다 큰 값들'이 정렬되어 있습니다.
# 따라서 g1, 기준값 , g2를 순서대로 이어 붙이면 정렬이 완료됩니다.

# [1,2,3,4] + [5] + [6,7,8,9,10]

# 결과
# [1,2,3,4,5,6,7,8,9,10]

list = [6, 8, 3, 9, 10, 1, 2, 4, 7, 5]  
g1=[]
g2=[]
    
def quick(a,G1,G2):
    if len(a) != 0:
        pivot = a[len(a)-1]
    else:
        break

    while a[0] != pivot:
        if a[0] < pivot:
            G1.insert(0,a[0])
            a.pop(0)
            continue
        else:
            G2.insert(0,a[0])
            a.pop(0)
            
    return a

def quick2(b,G3,G4):
    quick(b,G3,G4)
    group3=[]
    group4=[]
    quick(G3,group3,group4)
    group5=[]
    group6=[]
    quick(G3,group5,group6)
    
    group7=[]
    group8=[]
    quick(G4,group7,group8)
    group9=[]
    group10=[]
    quick(group7,group9,group10)


#    return a 

quick2(list,g1,g2)

 
# print(list) - [5] -> 함수외부에 있는 list값에 함수 안의 .pop는 영향을 주는데 
#g1+a+g2 는 영향을 안주는 이유?


